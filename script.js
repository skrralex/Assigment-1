
let state = Object.freeze({
    pointerEvent: { x: 0, y: 0 },
    velocity: {x:0, y:0},
    saturation: 0,
    hueValue: 1,
});

// The settings should contain all of the "fixed" parts of your programs, like static HTMLElements and paramaters.
const settings = Object.freeze({
    sample: {
        height: 100,
        width: 100,
        element: document.querySelector("#sample-output"),
        gravityConstant: 10,                                           //This is where GRAVITY can be adjusted.
    },
});


//Other variables.
let fallingSpeed = 1;                           
let startTime = 0;
let endTime = 0;
let normalisedValue = 0;
let saturationInterval = 0;

//Function to update the HSL values in the CSS file with the current HUE and SATURATION.
function updateColor() {
    const {sample} = settings;
    let {saturation} = state;
    let {hueValue} = state;
    sample.element.style.backgroundColor = `hsl(${hueValue}, ${saturation}%, 50%)`;
}

//Function to update the box shadow and turn it ON.
function boxShadowOn() {
    const {sample} = settings;
    sample.element.style.boxShadow = `3px 3px 10px 1px #555555`;
}

//Function to update the box shadow and turn it OFF.
function boxShadowOff() {
    const {sample} = settings;
    sample.element.style.boxShadow = `1px 1px 5px 1px #757575`;
}

// Function to check if the BOX SHADOW should be on or off.
function ifShadowShouldBeOn () {
    if ((Date.now()-startTime) > 1000) {
        boxShadowOff();
    }
}

//Function to generate a random number, that randomizes HUE.
function getRandom(max) {
    return Math.random() * max;
}

//Function to increment the SATURATION value.
function incrementSaturation() {
    let { saturation } = state;
    saturation += 1;
    updateState({saturation});           
    updateColor();                       
}

/**
 * Update the state object with the properties included in `newState`.
 * @param {Object} newState An object with the properties to update in the state object.
 */
function updateState(newState) {
    state = Object.freeze({ ...state, ...newState });
}

/**
 * Return `num` normalised to 0..1 in range min..max.
 * @param {number} num
 * @param {number} min 
 * @param {number} max 
 * @returns number
 */
function  scale(num, min, max){
    if (num < min) return 0;
    if (num > max) return 1;
    return (num - min) / (max - min);
}

/**
 * Return `num` transformed from the normalised 0..1 form back to the min..max form.
 * @param {number} num
 * @param {number} min 
 * @param {number} max 
 * @returns number
 */
function toAbsolute(num, min, max) {
    if (num < 0) return min;
    if (num > 1) return max;
    return (num * (max - min)) + min;
}

/**
 * This is where we put the code that transforms and outputs our data.
 * loop() is run every frame, assuming that we keep calling it with `window.requestAnimationFrame`.
 */
function loop() {
    const { pointerEvent } = state;
    const { sample } = settings;

    //Normalising the cursor coordinates for x and y.
    const cursorPoint = {
        x: scale(pointerEvent.x, 0, window.innerWidth),
        y: scale(pointerEvent.y, 0, window.innerHeight),
    }

    //Applying the cursor coordinates to the circle, compensating for the size of the circle and adding VELOCITY to the Y AXIS.
    const circlePoint = {
        x: toAbsolute(cursorPoint.x, 0, window.innerWidth) - (sample.width / 2),
        y: toAbsolute(cursorPoint.y, 0, window.innerHeight) - (sample.height / 2) + state.velocity.y,
    }

    //Making the circle stop at the bottom of the window.
    if (circlePoint.y > window.innerHeight - ((sample.height)+16)) {  //pixels are added so that the circle sits perfectly on the bottom.
        circlePoint.y = window.innerHeight - (sample.height+16);      //pixels are added so that the circle sits perfectly on the bottom.  
    }

    //Transforming the circle by sending the new coordinates to the HTML element.
    sample.element.style.transform = `translate(${circlePoint.x}px, ${circlePoint.y}px)`;

    //Velocity is created by continuously adding the product of gravityConstant and fallingSpeed.
    state.velocity.y += sample.gravityConstant*fallingSpeed;

    //Updates velocity in state.
    updateState({ velocity: state.velocity });

    window.requestAnimationFrame(loop);
}


/**
 * Setup is run once, at the start of the program. It sets everything up for us!
 */
function setup() {
    const { sample } = settings;

    let { saturation } = state;
    let { hueValue } = state;
    let checkingBoxShadowInterval = 0;

    let duration = 0;

    //The circle is generated by inputing height and width into the HTML element <p>.
    sample.element.style.height = `${sample.height}px`;
    sample.element.style.width = `${sample.width}px`;

    document.addEventListener("pointerdown", function (event) {
        //Updates the position of the circle, with the coordinates from the pointer.
        updateState({ pointerEvent: event });

        //Turns on BOX SHADOW when pressing down.
        boxShadowOn();

        //Set gravity and velocity to 0 with every new circle.
        fallingSpeed = 0;
        state.velocity.y = 0;

        //Starting time needed to calculate duration of the press.
        startTime = Date.now();

        //HUE is set by generating a random number between 0-360 and is stored in hueValue.
        hueValue = getRandom(360);

        //Updates the HUE and SATURATION values.
        updateState({hueValue, saturation});

        //Updates the color in CSS.
        updateColor();

        //The incrementSaturation function is called, with an interval and this value is stored in saturationInterval.
        saturationInterval = setInterval(incrementSaturation, 10); //10ms

        //The ifShadowShouldBeOn function is called at an interval, and the value is stored in checkingBoxShadowInterval.
        checkingBoxShadowInterval = setInterval(ifShadowShouldBeOn, 100);   // 100ms

        console.log("Hue: " + hueValue);                 //CONSOLE LOG
        
    });

    document.addEventListener("pointerup", function (event) {

        //Interval functions for SATURATION and BOX SHADOW are stopped when pointer is lifted.
        clearInterval(saturationInterval);
        clearInterval(checkingBoxShadowInterval);
   
        //End time needed to calculate duration of the press.
        endTime = Date.now();
        duration = (endTime - startTime);

        //NORMALISED VALUE is seconds translated into a 0-1 value. The opposite of what we need. 
        normalisedValue = scale(duration, 0, 1000); //Inputs are between 0 and 1000ms (1s).

        //To get the right FALLING SPEED, NORMALISED VALUE is subtracted from 1 and what is left becomes the FALLING SPEED applied. Adjust in gravityConstant.
        fallingSpeed = (1-normalisedValue);

        console.log("Duration: " + (duration/1000) + " seconds");
        console.log("Stickiness: " + (normalisedValue*100) + " %");

    });

    loop();
}

setup(); // Always remember to call setup()!
